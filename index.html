<!doctype html>
<html lang="en" prefix="og: http://ogp.me/ns#">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- SEO -->
	<title>WebSlides: Making HTML presentations easy</title>
	<meta name="description"
		content="WebSlides is the easiest way to make HTML presentations, portfolios, and landings. Just essential features.">

	<!-- Google Fonts -->
	<link
		href="https://fonts.googleapis.com/css?family=Roboto:100,100i,300,300i,400,400i,700,700i%7CMaitree:200,300,400,600,700&amp;subset=latin-ext"
		rel="stylesheet">

	<!-- CSS WebSlides -->
	<link rel="stylesheet" type='text/css' media='all' href="static/css/webslides.css">

	<!-- Optional - CSS SVG Icons (Font Awesome) -->
	<link rel="stylesheet" type='text/css' media='all' href="static/css/svg-icons.css">

	<!-- FAVICONS -->
	<link rel="shortcut icon" sizes="16x16" href="static/images/favicons/favicon.png">
	<link rel="shortcut icon" sizes="32x32" href="static/images/favicons/favicon-32.png">
	<link rel="apple-touch-icon icon" sizes="76x76" href="static/images/favicons/favicon-76.png">
	<link rel="apple-touch-icon icon" sizes="120x120" href="static/images/favicons/favicon-120.png">
	<link rel="apple-touch-icon icon" sizes="152x152" href="static/images/favicons/favicon-152.png">
	<link rel="apple-touch-icon icon" sizes="180x180" href="static/images/favicons/favicon-180.png">
	<link rel="apple-touch-icon icon" sizes="192x192" href="static/images/favicons/favicon-192.png">

	<!-- Android -->
	<meta name="mobile-web-app-capable" content="yes">
	<meta name="theme-color" content="#333333">
</head>

<body>
	<main role="main">
		<article id="webslides" class="vertical">
			<section class="bg-primary">
				<div class="wrap aligncenter">
					<h1><strong>Going offline</strong></h1>
					<br>
					<p class="text-intro">Synchronization Architecture for SalesRep</p>
					<hr>
					<p>Aphix Software</p>
				</div>
			</section>



			<section class="bg-secondarys">
				<div class="wrap aligncenter">
					<h1>Vision</h1>

					<br>

					<p class="text-intro">
						Developing an offline-first solution for sale representatives
						<br>
						which enables ERP management on the move
					</p>
				</div>
			</section>

			<section class="my-images">
				<div class="wrap">
					<h2>Technologies</h2>

					<br>

					<ul class="flexblock features">
						<li>
							<div>
								<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/97/Sqlite-square-icon.svg/1024px-Sqlite-square-icon.svg.png"
									alt="">
								<h2>SQLite</h2>
								<p>Native</p>
								<p><small>Database</small></p>
							</div>
						</li>
						<li>
							<div>
								<img src="https://cdn.freebiesupply.com/logos/thumbs/2x/pouchdb-logo.png" alt="">
								<h2>Pouch DB</h2>
								<p>Sync Interface</p>
								<p><small>Database</small></p>
							</div>
						</li>
						<li>
							<div>
								<img src="https://cdn.freebiesupply.com/logos/large/2x/couchdb-1-logo-png-transparent.png"
									alt="">
								<h2>Couch DB</h2>
								<p>Aphix Cloud</p>
								<p><small>Database</small></p>
							</div>
						</li>

						<li>
							<div>
								<img src="https://cdn.worldvectorlogo.com/logos/react.svg" alt="">
								<h2>React</h2>
								<p>Design System</p>
								<p><small>Library</small></p>
							</div>
						</li>
						<li>
							<div>
								<img src="https://miro.medium.com/max/2800/0*U2DmhXYumRyXH6X1.png" alt="">
								<h2>Redux</h2>
								<p>State Management</p>
								<p><small>Library</small></p>
							</div>
						</li>
						<li>
							<div>
								<img src="https://cordova.apache.org/static/img/cordova_256.png" alt="">
								<h2>Cordova</h2>
								<p>Native Wrapper</p>
								<p><small>WebView</small></p>
							</div>
						</li>
					</ul>
				</div>
			</section>

			<section class="bg-primary">
				<div class="wrap aligncenter">
					<h2>Server Side</h2>
				</div>
			</section>

			<section>
				<div class="wrap aligncenter">
					<h2>Aphix Cloud</h2>
					<br>
					<div class="grid vertical-align">
						<div class="column">
							<p>
								Interrogates external ERP systems and forwards records into our database.
								Storage imposes internal schema and record integrity for our needs.
							</p>

							<p>
								Direct record access via RESTful API would be forbidden in favor of
								database access. Such approach would ease synchronisation and live data
								feed for SalesRep.
							</p>
						</div>
						<div class="column">
							<figure>
								<img class="aligncenter logo-circle"
									src="https://pbs.twimg.com/profile_images/651476318362714113/j-E9kVBf_400x400.png"
									alt="iPhone">
							</figure>
						</div>
						<div class="column">
							<ul class="flexblock specs">
								<li>
									<div>
										<h2>ERP Record Persistence</h2>
										<p>Core communicates with external ERPs and inserts records into CouchDB</p>
									</div>
								</li>
								<li>
									<div>
										<h2>Infrastructure</h2>
										<p>Handles record integrity and issue monitoring</p>
									</div>
								</li>
								<li>
									<div>
										<h2>WebShop</h2>
										<p>E-commerce support</p>
									</div>
								</li>
							</ul>
						</div>
					</div>
			</section>

			<section>
				<div class="wrap aligncenter">
					<h2>Couch & Pouch</h2>
					<br>
					<div class="grid vertical-align">
						<div class="column">
							<p>
								CouchDB would retain original data from external ERPs while PouchDB
								would be our interface layer for accessing those records. 
							</p>

							<p>
								SalesRep clients will be aware of PouchDB's context through it's direct API.
								And PouchDB would take care of CouchDB syncchronisation and memory offloading
								to SQLite.
							</p>

							<p>
								Benefit - we gain free sync between Aphix Cloud and SalesRep.
								SQLite would be installed together with SalesRep on mobile devices.
							</p>
						</div>

						<div class="column">
							<figure>
								<img class="aligncenter logo-circle"
									src="https://www.joshmorony.com/media/2016/06/pouchdb-couchdb.png" alt="iPhone">
							</figure>
						</div>

						<div class="column">
							<ul class="flexblock specs">
								<li>
									<div>
										<h2>Synchronisation</h2>
										<p>Automatic syncrhonisation via HTTP protocol</p>
									</div>
								</li>
								<li>
									<div>
										<h2>Browser Databases</h2>
										<p>
											Offline stability with browser storage fallback
										</p>
									</div>
								</li>
								<li>
									<div>
										<h2>Native</h2>
										<p>Browser fallback is replaced by SQLite</p>
									</div>
								</li>
							</ul>
						</div>
					</div>
			</section>

			<section class="bg-primary">
				<div class="wrap aligncenter">
					<h2>Client Side</h2>
				</div>
			</section>

			<section>
				<div class="wrap aligncenter size-50">
					<h2>Initialisation</h2>
					<br>
					<p>
						Essentially SalesRep needs boot up and preform initial state
						without without race conditions. Also retaining control
						over full application's state without design system's awareness.
					</p>
					<ul class="flexblock specs">
						<li>
							<h2>Component rendering</h2>
							<p>Routing</p>
						</li>
						<li>
							<h2>Database transactions</h2>
							<p>Side effects</p>
						</li>
					</ul>
				</div>
			</section>


			<section>
				<div class="wrap aligncenter">
					<div class="grid vertical-align">
						<div class="column">
							<p>
								It is important to allow Redux to sunc with component life cycle.
								We are able to dispatch actions, traverse state in middleware via selectors
								and conditionally redirect users through views.
							</p>

							<p>
								External state modifications are external from components and it is
								crucial to keep them seperate.
							</p>
						</div>

						<div class="column">
							<pre>
export const Root = ({ history, store }) => (
  &lt;Router history={history}&gt;
    &lt;Provider store={store}&gt;
      &lt;AppContainer /&gt;
    &lt;/Provider&gt;
  &lt;/Router&gt;
);

...

ReactDOM.render(
  &lt;Root store={store} history={history} /&gt;,
  document.getElementById('root'),
);
							</pre>
						</div>
					</div>
				</div>
			</section>


			<section>
				<div class="wrap aligncenter">
					<div class="grid vertical-align">
						<div class="column">
							<p>
								Here we are initialising state via composed reducers. Applied middleware
								allows us to customize side effect handling while keeping application's
								state encapulsated and not poluted with store imports.
							</p>
						</div>

						<div class="column">
							<pre>
const reducer = (state = 0) => state;

const middleware = {
  saga: createSagaMiddleware({ }),
  pouch: createPouchMiddleware({ }),
  logger: createLoggerMiddleware({ }),
};

const store = Redux.createStore(
  reducer,
  Redux.applyMiddleware(
    ...Object.values(middleware),
  ),
);

middleware.saga.run(sagas);
							</pre>
						</div>
					</div>
				</div>
			</section>


			<section>
				<div class="wrap aligncenter">
					<div class="grid vertical-align">
						<div class="column">
							<p>
								With whole application's state we can orchestrate series of parallel
								actions to sync and validate resource connection.
							</p>

							<p>
								In this example we are currying our generator by specifying which
								resource we're inclined to take for the request and a handler. Alternatively
								requesting resource address on failure via service-worker and setting state
								parameters if such resource is available.
							</p>

							<p>
								I think there are advantages of persisting resource addresses in state
								as we can conditionally preform actions and render components. Another advantage
								is where we might preform a form submittion  via POST to a resource for
								credential validation Service is offline and therefore we might cache it
								for later validation when the resource comes online.
							</p>

							<p>
								In micro-services architectures, we cannot know if those services were
								started to begin with.
							</p>
						</div>

						<div class="column">
							<pre>
export const handleRequest = (resource, saga) => function* (action) {
  try {
    const { host, status } = yield ReduxSaga.effects.select(
      Resource.get(resource)
    );

    if (status == false) {
      yield ReduxSaga.effects.fork(requestResource, resource);
    } else {
      yield ReduxSaga.effects.fork(saga, host);
    }
  } catch (error) {
    yield ReduxSaga.effects.put(
      Resource.setStatus(resource, false)
    );
  }
}

export default [
  ReduxSaga.effects.takeEvery(
    'PRODUCTS_FETCH',
    handleRequest('coreService', fetchProducts),
  ),
  ...
];
							</pre>
						</div>
					</div>
				</div>
			</section>

			<section>
				<div class="wrap aligncenter size-50">
					<h2>Routing</h2>
					<br>
					<p>
						Considering how deeply nested our component hierarchy can become. Owning
						a single component responsible for multiple states would need to be researched
						as I wouldn't remember how to maintain such components. But...
					</p>
					<p>
						I would suggest creating view components which define basic internal state
						for layout, theme's and media queries. And route endpoints for container components.
					</p>
					<p>
						We can also configure our history context to be one of browser/hash/memory for
						out development environment to inspect state during redirect.
					</p>
					<ul class="flexblock specs">
						<li>
							<h2>Prioritizing which views render initially</h2>
							<p>Lazy loading</p>
						</li>
						<li>
							<h2>Pattern matched routes</h2>
							<p>Routes</p>
						</li>
					</ul>
				</div>
			</section>

			<section>
				<div class="wrap aligncenter">
					<div class="grid vertical-align">
						<div class="column">
							<p>
								Another suggestion would be to utilize route conditional rendering over
								state. We could still preform side effects but on failure we would
								preform a redirect to load requied state via parameters from PouchDB.
							</p>

							<p>
								Note when the user has been selected, it is possible to view user
								details and toggle appropriate sidebar menu for that user. Transitional
								route animations could also be applied via utility component which
								wraps around <em>ReactRouterDOM.Switch</em>.
							</p>
						</div>

						<div class="column">
							<pre>
export default = () => (
  &lt;Layout flex&gt;
    &lt;Sidebar&gt;
      &lt;Switch&gt;
        &lt;Route path="/user/:id" component={UserMenu} /&gt;
        &lt;Route path="/" component={Menu} /&gt;
      &lt;/Switch&gt;
    &lt;/Sidebar&gt;
    &lt;Layout&gt;
      &lt;Navbar /&gt;
      &lt;Main&gt;
        &lt;Switch&gt;
          &lt;Route path="/user/:id" component={UserDetails} /&gt;
          &lt;Route path="/" component={Dashboard} /&gt;
        &lt;/Switch&gt;
      &lt;/Main&gt;
    &lt;/Layout&gt;
  &lt;/Layout&gt;
);
							</pre>
						</div>
					</div>
				</div>
			</section>


			<section>
				<div class="wrap aligncenter">
					<div class="grid vertical-align">
						<div class="column">
							<p>
								Combinding that with lazy loading, we could rely on something neat.
								Would it be a website we could create notifications with URLs resolving
								to any portion inside the app. We could even have internal links.
							</p>
							</p>
						</div>

						<div class="column">
							<pre>
const A = React.lazy(() => import('../views/A/A.component'));
const B = React.lazy(() => import('../views/B/B.component'));
const C = React.lazy(() => import('../views/C/C.component'));
const ErrorBoundry = React.lazy(
  () => import('../views/ErrorBoundry/ErrorBoundry.component')
);

export default = () => (
  &lt;Switch&gt;
    &lt;Route path="/a" component={A} /&gt;
    &lt;Route path="/b" component={B} /&gt;
    &lt;Route path="/c" component={C} /&gt;
    &lt;Route path="/error" component={ErrorBoundry} /&gt;
  &lt;/Switch&gt;
);
							</pre>
						</div>
					</div>
				</div>
			</section>

		</article>
	</main>

	<script src="static/js/webslides.js"></script>
	<script>
		window.ws = new WebSlides();
	</script>

	<script defer src="static/js/svg-icons.js"></script>
</body>

</html>