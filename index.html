<!doctype html>
<html lang="en" prefix="og: http://ogp.me/ns#">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- SEO -->
	<title>WebSlides: Making HTML presentations easy</title>
	<meta name="description"
		content="WebSlides is the easiest way to make HTML presentations, portfolios, and landings. Just essential features.">

	<!-- Google Fonts -->
	<link
		href="https://fonts.googleapis.com/css?family=Roboto:100,100i,300,300i,400,400i,700,700i%7CMaitree:200,300,400,600,700&amp;subset=latin-ext"
		rel="stylesheet">

	<!-- CSS WebSlides -->
	<link rel="stylesheet" type='text/css' media='all' href="static/css/webslides.css">

	<!-- Optional - CSS SVG Icons (Font Awesome) -->
	<link rel="stylesheet" type='text/css' media='all' href="static/css/svg-icons.css">

	<!-- FAVICONS -->
	<link rel="shortcut icon" sizes="16x16" href="static/images/favicons/favicon.png">
	<link rel="shortcut icon" sizes="32x32" href="static/images/favicons/favicon-32.png">
	<link rel="apple-touch-icon icon" sizes="76x76" href="static/images/favicons/favicon-76.png">
	<link rel="apple-touch-icon icon" sizes="120x120" href="static/images/favicons/favicon-120.png">
	<link rel="apple-touch-icon icon" sizes="152x152" href="static/images/favicons/favicon-152.png">
	<link rel="apple-touch-icon icon" sizes="180x180" href="static/images/favicons/favicon-180.png">
	<link rel="apple-touch-icon icon" sizes="192x192" href="static/images/favicons/favicon-192.png">

	<!-- Android -->
	<meta name="mobile-web-app-capable" content="yes">
	<meta name="theme-color" content="#333333">
</head>

<body>
	<main role="main">
		<article id="webslides" class="vertical">
			<section class="bg-primary">
				<div class="wrap aligncenter">
					<h1><strong>Going offline</strong></h1>
					<br>
					<p class="text-intro">Synchronization Architecture for SalesRep</p>
					<hr>
					<p>Aphix Software</p>
				</div>
			</section>



			<section class="bg-secondarys">
				<div class="wrap aligncenter">
					<h1>Vision</h1>

					<br>

					<p class="text-intro">
						Developing an offline-first solution for sale representatives
						<br>
						which enables ERP management on the move
					</p>
				</div>
			</section>

			<section class="my-images">
				<div class="wrap">
					<h2>Technologies</h2>

					<br>

					<ul class="flexblock features">
						<li>
							<div>
								<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/97/Sqlite-square-icon.svg/1024px-Sqlite-square-icon.svg.png"
									alt="">
								<h2>SQLite</h2>
								<p>Native</p>
								<p><small>Database</small></p>
							</div>
						</li>
						<li>
							<div>
								<img src="https://cdn.freebiesupply.com/logos/thumbs/2x/pouchdb-logo.png" alt="">
								<h2>Pouch DB</h2>
								<p>Sync Interface</p>
								<p><small>Database</small></p>
							</div>
						</li>
						<li>
							<div>
								<img src="https://cdn.freebiesupply.com/logos/large/2x/couchdb-1-logo-png-transparent.png"
									alt="">
								<h2>Couch DB</h2>
								<p>Aphix Cloud</p>
								<p><small>Database</small></p>
							</div>
						</li>

						<li>
							<div>
								<img src="https://cdn.worldvectorlogo.com/logos/react.svg" alt="">
								<h2>React</h2>
								<p>Design System</p>
								<p><small>Library</small></p>
							</div>
						</li>
						<li>
							<div>
								<img src="https://miro.medium.com/max/2800/0*U2DmhXYumRyXH6X1.png" alt="">
								<h2>Redux</h2>
								<p>State Management</p>
								<p><small>Library</small></p>
							</div>
						</li>
						<li>
							<div>
								<img src="https://cordova.apache.org/static/img/cordova_256.png" alt="">
								<h2>Cordova</h2>
								<p>Native Wrapper</p>
								<p><small>WebView</small></p>
							</div>
						</li>
					</ul>
				</div>
			</section>

			<section class="bg-primary">
				<div class="wrap aligncenter">
					<h2>Server Side</h2>
				</div>
			</section>

			<section>
				<div class="wrap aligncenter">
					<h2>Aphix Cloud</h2>
					<br>
					<div class="grid vertical-align">
						<div class="column">
							<p>
								Interrogates external ERP systems and forwards records into our database.
								Storage imposes internal schema and record integrity for our needs.
							</p>

							<p>
								Cloud would be open for HTTP requests in relation to authentication
								and other request unrelated to products, categories, contacts etc.
							</p>
						</div>
						<div class="column">
							<figure>
								<img class="aligncenter logo-circle"
									src="https://pbs.twimg.com/profile_images/651476318362714113/j-E9kVBf_400x400.png"
									alt="iPhone">
							</figure>
						</div>
						<div class="column">
							<ul class="flexblock specs">
								<li>
									<div>
										<h2>ERP Record Persistence</h2>
										<p>Core communicates with external ERPs and inserts records into CouchDB</p>
									</div>
								</li>
								<li>
									<div>
										<h2>Infrastructure</h2>
										<p>Handles record integrity and issue monitoring</p>
									</div>
								</li>
								<li>
									<div>
										<h2>WebShop</h2>
										<p>E-commerce support</p>
									</div>
								</li>
							</ul>
						</div>
					</div>
			</section>

			<section>
				<div class="wrap aligncenter">
					<h2>Couch & Pouch</h2>
					<br>
					<div class="grid vertical-align">
						<div class="column">
							<p>
								CouchDB would retain original data from external ERPs while PouchDB
								would be our interface layer for accessing those records. 
							</p>

							<p>
								SalesRep clients will be aware of PouchDB's context through it's direct API.
								And PouchDB would take care of CouchDB synchronisation and memory offloading
								to SQLite.
							</p>

							<p>
								Benefit - we gain free sync between Aphix Cloud and SalesRep.
								SQLite would be installed together with SalesRep on mobile devices.
							</p>
						</div>

						<div class="column">
							<figure>
								<img class="aligncenter logo-circle"
									src="https://www.joshmorony.com/media/2016/06/pouchdb-couchdb.png" alt="iPhone">
							</figure>
						</div>

						<div class="column">
							<ul class="flexblock specs">
								<li>
									<div>
										<h2>Synchronisation</h2>
										<p>Automatic syncrhonisation via HTTP protocol</p>
									</div>
								</li>
								<li>
									<div>
										<h2>Browser Databases</h2>
										<p>
											Offline stability with browser storage fallback
										</p>
									</div>
								</li>
								<li>
									<div>
										<h2>Native</h2>
										<p>Browser fallback is replaced by SQLite</p>
									</div>
								</li>
							</ul>
						</div>
					</div>
			</section>

			<section class="bg-primary">
				<div class="wrap aligncenter">
					<h2>Client Side</h2>
				</div>
			</section>

			<section>
				<div class="wrap aligncenter size-50">
					<h2>Initialisation</h2>
					<br>
					<p>
						Essentially SalesRep needs boot up and preform initial state
						without without race conditions. Also retaining control
						over full application's state without design system's awareness.
					</p>
					<ul class="flexblock specs">
						<li>
							<h2>Component rendering</h2>
							<p>Routing</p>
						</li>
						<li>
							<h2>Database transactions</h2>
							<p>Side effects</p>
						</li>
					</ul>
				</div>
			</section>


			<section>
				<div class="wrap aligncenter">
					<div class="grid vertical-align">
						<div class="column">
							<p>
								It is important to allow Redux to sunc with component life cycle.
								We are able to dispatch actions, traverse state in middleware via selectors
								and conditionally redirect users through views.
							</p>

							<p>
								External state modifications are external from components and it is
								crucial to keep them seperate.
							</p>
						</div>

						<div class="column">
							<pre>
export const Root = ({ history, store }) => (
  &lt;Router history={history}&gt;
    &lt;Provider store={store}&gt;
      &lt;AppContainer /&gt;
    &lt;/Provider&gt;
  &lt;/Router&gt;
);

...

ReactDOM.render(
  &lt;Root store={store} history={history} /&gt;,
  document.getElementById('root'),
);
							</pre>
						</div>
					</div>
				</div>
			</section>


			<section>
				<div class="wrap aligncenter">
					<div class="grid vertical-align">
						<div class="column">
							<p>
								Here we are initialising state via composed reducers. Applied middleware
								allows us to customize side effect handling while keeping application's
								state encapulsated and not poluted with store imports.
							</p>
						</div>

						<div class="column">
							<pre>
const reducer = (state = 0) => state;

const middleware = {
  saga: createSagaMiddleware({ }),
  pouch: createPouchMiddleware({ }),
  logger: createLoggerMiddleware({ }),
};

const store = Redux.createStore(
  reducer,
  Redux.applyMiddleware(
    ...Object.values(middleware),
  ),
);

middleware.saga.run(sagas);
							</pre>
						</div>
					</div>
				</div>
			</section>


			<section>
				<div class="wrap aligncenter">
					<div class="grid vertical-align">
						<div class="column">
							<p>
								With whole application's state we can orchestrate series of parallel
								actions to sync and validate resource connection.
							</p>

							<p>
								In this example we are currying our generator by specifying which
								resource we're inclined to take for the request and a handler. Alternatively
								requesting resource address on failure via service-worker and setting state
								parameters if such resource is available.
							</p>

							<p>
								I think there are advantages of persisting resource addresses in state
								as we can conditionally preform actions and render components. Another advantage
								is where we might preform a form submittion  via POST to a resource for
								credential validation Service is offline and therefore we might cache it
								for later validation when the resource comes online.
							</p>

							<p>
								In micro-services architectures, we cannot know if those services were
								started to begin with.
							</p>
						</div>

						<div class="column">
							<pre>
export const handleRequest = (resource, saga) => function* (action) {
  try {
    const { host, status } = yield ReduxSaga.effects.select(
      Resource.get(resource)
    );

    if (status == false) {
      yield ReduxSaga.effects.fork(requestResource, resource);
    } else {
      yield ReduxSaga.effects.fork(saga, host);
    }
  } catch (error) {
    yield ReduxSaga.effects.put(
      Resource.setStatus(resource, false)
    );
  }
}

export default [
  ReduxSaga.effects.takeEvery(
    Product.PRODUCTS_FETCH,
    handleRequest('coreService', fetchProducts),
  ),
  ...
];
							</pre>
						</div>
					</div>
				</div>
			</section>

			<section>
				<div class="wrap aligncenter size-50">
					<h2>Routing</h2>
					<br>
					<p>
						Considering how deeply nested our component hierarchy can become. Owning
						a single component responsible for multiple states would need to be researched
						as I wouldn't remember how to maintain such components. But...
					</p>
					<p>
						I would suggest creating view components which define basic internal state
						for layout, theme's and media queries. And route endpoints for container components.
					</p>
					<p>
						We can also configure our history context to be one of browser/hash/memory for
						out development environment to inspect state during redirect.
					</p>
					<ul class="flexblock specs">
						<li>
							<h2>Prioritizing which views render initially</h2>
							<p>Lazy loading</p>
						</li>
						<li>
							<h2>Pattern matched routes</h2>
							<p>Routes</p>
						</li>
					</ul>
				</div>
			</section>

			<section>
				<div class="wrap aligncenter">
					<div class="grid vertical-align">
						<div class="column">
							<p>
								Another suggestion would be to utilize route conditional rendering over
								state. We could still preform side effects but on failure we would
								preform a redirect to load requied state via parameters from PouchDB.
							</p>

							<p>
								Note when the user has been selected, it is possible to view user
								details and toggle appropriate sidebar menu for that user. Transitional
								route animations could also be applied via utility component which
								wraps around <em>ReactRouterDOM.Switch</em>.
							</p>
						</div>

						<div class="column">
							<pre>
export default = () => (
  &lt;Layout flex&gt;
    &lt;Sidebar&gt;
      &lt;Switch&gt;
        &lt;Route path="/user/:id" component={UserMenu} /&gt;
        &lt;Route path="/" component={Menu} /&gt;
      &lt;/Switch&gt;
    &lt;/Sidebar&gt;
    &lt;Layout&gt;
      &lt;Navbar /&gt;
      &lt;Main&gt;
        &lt;Switch&gt;
          &lt;Route path="/user/:id" component={UserDetails} /&gt;
          &lt;Route path="/" component={Dashboard} /&gt;
        &lt;/Switch&gt;
      &lt;/Main&gt;
    &lt;/Layout&gt;
  &lt;/Layout&gt;
);
							</pre>
						</div>
					</div>
				</div>
			</section>


			<section>
				<div class="wrap aligncenter">
					<div class="grid vertical-align">
						<div class="column">
							<p>
								Combinding that with lazy loading, we could rely on something neat.
								Would it be a website we could create notifications with URLs resolving
								to any portion inside the app. We could even have internal links.
							</p>
							</p>
						</div>

						<div class="column">
							<pre>
const A = React.lazy(() => import('../views/A/A.component'));
const B = React.lazy(() => import('../views/B/B.component'));
const C = React.lazy(() => import('../views/C/C.component'));

const ErrorBoundry = React.lazy(
  () => import('../views/ErrorBoundry/ErrorBoundry.component')
);

export default = () => (
  &lt;Switch&gt;
    &lt;Route path="/a" component={A} /&gt;
    &lt;Route path="/b" component={B} /&gt;
    &lt;Route path="/c" component={C} /&gt;
    &lt;Route path="/error" component={ErrorBoundry} /&gt;
  &lt;/Switch&gt;
);
							</pre>
						</div>
					</div>
				</div>
			</section>

			<section class="bg-primary">
				<div class="wrap aligncenter">
					<h2>State Management</h2>
				</div>
			</section>

			<section>
				<div class="wrap aligncenter size-50">
					<h2>Containers</h2>
					<br>
					<p>
						There is a common practice to create special components which wrap
						state from Redux and pass it along to other components. Ideally they
						sould be placed stand alone or as views bound to routable paths. So that
						whenever user lands on a specific page, required properties will be provided
						to the view.
					</p>
					<ul class="flexblock specs">
						<li>
							<h2>Utilizing selector pattern</h2>
							<p>State retrieval</p>
						</li>
						<li>
							<h2>Action dispatching revolving around state</h2>
							<p>Dispatchers</p>
						</li>
					</ul>
				</div>
			</section>


			<section>
				<div class="wrap aligncenter">
					<div class="grid vertical-align">
						<div class="column">
							<p>
								These components are able to retrieve state and provide side effect
								actions. Selector pattern shines as they can be used similar to LINQ
								against a centralized store. They can be composed and memoized
								for those data sources refered to as container components.
							</p>

							<p>
								Views depending on specific state elements can be passed down from
								parents or select their own information.
							</p>
						</div>

						<div class="column">
							<pre>
export default React.memo(({ match: { params: { categoryId } } }) => {
  const dispatch = ReactRedux.useDispatch();

  const category = ReactRedux.useSelector(
	Category.find(categoryId),
	ReactRedux.shallowEqual,
  );

  const products = ReactRedux.useSelector(
	Products.getByCategory(categoryId),
	ReactRedux.shallowEqual,
  );

  const handleUpdateCategory = React.useCallback(
    categoryName => dispatch(
      Category.updateFilter(categoryName)
    ),
    [categoryId],
  );

  return (
    &lt;View
      {...({ products, category })}
      onUpdateCategory={handleUpdateCategory}
    /&gt;
  );
});
							</pre>
						</div>
					</div>
				</div>
			</section>

			<section>
				<div class="wrap aligncenter size-50">
					<h2>Forms</h2>
					<br>
					<p>
						We could build reusable forms and save them in store as entities or
						configurations. Where the app would store them and follow up on different
						actions. But those entities would be flagged as un-validated while SalesRep
						is offline and cannot authorize certaon objects.
					</p>

					<p>
						Surely we can create objects and validate them on client side, but some schemas
						require approval and follow certain constraints. Usually those constraints reside
						on the server. And formal concepts like field validation would have to be compramised.
					</p>
					<ul class="flexblock specs">
						<li>
							<h2>Form segment for it's context</h2>
							<p>UI</p>
						</li>
						<li>
							<h2>Consistent form validation</h2>
							<p>Schema validation</p>
						</li>
						<li>
							<h2>Submitting results to server</h2>
							<p>Submit handling</p>
						</li>
					</ul>
				</div>
			</section>

			<section>
				<div class="wrap aligncenter">
					<div class="grid vertical-align">
						<div class="column">
							<p>
								Simple form would be broken down into fields and formik properties.
								This would allow for composability and submit would vary by use case.
								Would be no harm to create a container component to maintain state for
								that form.
							</p>
						</div>

						<div class="column">
							<pre>
export const schema = Yup.object().shape({
  username: Yup.string().require('Username is required'),
  password: Yup.string().require('Password is required'),
});

export default = ({ username, password, onSubmit }) => {
  const form = Formik.useFormik({
    initialValues: { username, password },
    validationSchema: schema,
    handleSubmit: onSubmit,
  });

  return (
    &lt;Form&gt;
      &lt;Field name="username" /&gt;
      &lt;Field type="password" name="password" /&gt;
    &lt;/Form&gt;
  );
};
							</pre>
						</div>
					</div>
				</div>
			</section>


			<section>
				<div class="wrap aligncenter">
					<div class="grid vertical-align">
						<div class="column">
							<p>
								Login container would be responsive to read the user from state and
								utilize current set values. Then on submit it would traverse the
								middleware to preform a HTTP request to validate the user. On success
								the user would persist in the database with nre changes. Otherwise
								we could queue it inside PouchDB and preform the validation at a later date.
							</p>

							<p>
								Complication arises is that the user might be limited with what he/she can
								do as we're uncertain if the provided data is valid.
							</p>
						</div>

						<div class="column">
							<pre>
export default () => {
  const dispatch = ReactRedux.useDispatch();

  const user = ReactRedux.useSelector(
    User.get,
    ReactRedux.shallowEqual,
  );

  const handleSubmit = React.useCallback(
    ({ username, password }) => Account.login(username, password),
    [user],
  );

  return (
    &lt;Login {...user} onSubmit={handleSubmit} /&gt;
  );
};
							</pre>
						</div>
					</div>
				</div>
			</section>

			<section>
				<div class="wrap aligncenter">
					<div class="grid vertical-align">
						<div class="column">
							<p>
								Login container would be responsive to read the user from state and
								utilize current set values. Then on submit it would traverse the
								middleware to preform a HTTP request to validate the user. On success
								the user would persist in the database with nre changes. Otherwise
								we could queue it inside PouchDB and preform the validation at a later date.
							</p>

							<p>
								Complication arises is that the user might be limited with what he/she can
								do as we're uncertain if the provided data is valid.
							</p>
						</div>

						<div class="column">
							<pre>
export const login = (username, password) => ({
  type: USER_LOGIN,
  payload: { username, password },
});

...

export function* login({ payload: { username, password } }, host) {
  try {
    const request = yield ReduxSaga.effects.call(`${host}/user`, {
      method: 'POST',
      headers: { ...magic_tokens }
      body: JSON.stringify({ username, password }),
    });

    const response = yield ReduxSaga.effects.call(request.json);
    ...
  } catch (error) {
    ...
  }
};
							</pre>
						</div>
					</div>
				</div>
			</section>

			<section class="bg-primary">
				<div class="wrap aligncenter">
					<h2>Thanking you</h2>
				</div>
			</section>

		</article>
	</main>

	<script src="static/js/webslides.js"></script>
	<script>
		window.ws = new WebSlides();
	</script>

	<script defer src="static/js/svg-icons.js"></script>
</body>

</html>